// Code generated by MockGen. DO NOT EDIT.
// Source: repository.go
//
// Generated by this command:
//
//	mockgen -source=repository.go -destination=../mock/bigmapdiff/mock.go -package=bigmapdiff -typed
//
// Package bigmapdiff is a generated GoMock package.
package bigmapdiff

import (
	context "context"
	reflect "reflect"

	bigmapdiff "github.com/mavryk-network/bcdhub/internal/models/bigmapdiff"
	gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *MockRepository) Count(ctx context.Context, ptr int64) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ctx, ptr)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockRepositoryMockRecorder) Count(ctx, ptr any) *RepositoryCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockRepository)(nil).Count), ctx, ptr)
	return &RepositoryCountCall{Call: call}
}

// RepositoryCountCall wrap *gomock.Call
type RepositoryCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryCountCall) Return(arg0 int, arg1 error) *RepositoryCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryCountCall) Do(f func(context.Context, int64) (int, error)) *RepositoryCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryCountCall) DoAndReturn(f func(context.Context, int64) (int, error)) *RepositoryCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Current mocks base method.
func (m *MockRepository) Current(ctx context.Context, keyHash string, ptr int64) (bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Current", ctx, keyHash, ptr)
	ret0, _ := ret[0].(bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Current indicates an expected call of Current.
func (mr *MockRepositoryMockRecorder) Current(ctx, keyHash, ptr any) *RepositoryCurrentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Current", reflect.TypeOf((*MockRepository)(nil).Current), ctx, keyHash, ptr)
	return &RepositoryCurrentCall{Call: call}
}

// RepositoryCurrentCall wrap *gomock.Call
type RepositoryCurrentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryCurrentCall) Return(arg0 bigmapdiff.BigMapState, arg1 error) *RepositoryCurrentCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryCurrentCall) Do(f func(context.Context, string, int64) (bigmapdiff.BigMapState, error)) *RepositoryCurrentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryCurrentCall) DoAndReturn(f func(context.Context, string, int64) (bigmapdiff.BigMapState, error)) *RepositoryCurrentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockRepository) Get(ctx context.Context, reqCtx bigmapdiff.GetContext) ([]bigmapdiff.Bucket, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, reqCtx)
	ret0, _ := ret[0].([]bigmapdiff.Bucket)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockRepositoryMockRecorder) Get(ctx, reqCtx any) *RepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockRepository)(nil).Get), ctx, reqCtx)
	return &RepositoryGetCall{Call: call}
}

// RepositoryGetCall wrap *gomock.Call
type RepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetCall) Return(arg0 []bigmapdiff.Bucket, arg1 error) *RepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetCall) Do(f func(context.Context, bigmapdiff.GetContext) ([]bigmapdiff.Bucket, error)) *RepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetCall) DoAndReturn(f func(context.Context, bigmapdiff.GetContext) ([]bigmapdiff.Bucket, error)) *RepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetByPtr mocks base method.
func (m *MockRepository) GetByPtr(ctx context.Context, contract string, ptr int64) ([]bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByPtr", ctx, contract, ptr)
	ret0, _ := ret[0].([]bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByPtr indicates an expected call of GetByPtr.
func (mr *MockRepositoryMockRecorder) GetByPtr(ctx, contract, ptr any) *RepositoryGetByPtrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPtr", reflect.TypeOf((*MockRepository)(nil).GetByPtr), ctx, contract, ptr)
	return &RepositoryGetByPtrCall{Call: call}
}

// RepositoryGetByPtrCall wrap *gomock.Call
type RepositoryGetByPtrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetByPtrCall) Return(arg0 []bigmapdiff.BigMapState, arg1 error) *RepositoryGetByPtrCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetByPtrCall) Do(f func(context.Context, string, int64) ([]bigmapdiff.BigMapState, error)) *RepositoryGetByPtrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetByPtrCall) DoAndReturn(f func(context.Context, string, int64) ([]bigmapdiff.BigMapState, error)) *RepositoryGetByPtrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetByPtrAndKeyHash mocks base method.
func (m *MockRepository) GetByPtrAndKeyHash(ctx context.Context, ptr int64, keyHash string, size, offset int64) ([]bigmapdiff.BigMapDiff, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByPtrAndKeyHash", ctx, ptr, keyHash, size, offset)
	ret0, _ := ret[0].([]bigmapdiff.BigMapDiff)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetByPtrAndKeyHash indicates an expected call of GetByPtrAndKeyHash.
func (mr *MockRepositoryMockRecorder) GetByPtrAndKeyHash(ctx, ptr, keyHash, size, offset any) *RepositoryGetByPtrAndKeyHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPtrAndKeyHash", reflect.TypeOf((*MockRepository)(nil).GetByPtrAndKeyHash), ctx, ptr, keyHash, size, offset)
	return &RepositoryGetByPtrAndKeyHashCall{Call: call}
}

// RepositoryGetByPtrAndKeyHashCall wrap *gomock.Call
type RepositoryGetByPtrAndKeyHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetByPtrAndKeyHashCall) Return(arg0 []bigmapdiff.BigMapDiff, arg1 int64, arg2 error) *RepositoryGetByPtrAndKeyHashCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetByPtrAndKeyHashCall) Do(f func(context.Context, int64, string, int64, int64) ([]bigmapdiff.BigMapDiff, int64, error)) *RepositoryGetByPtrAndKeyHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetByPtrAndKeyHashCall) DoAndReturn(f func(context.Context, int64, string, int64, int64) ([]bigmapdiff.BigMapDiff, int64, error)) *RepositoryGetByPtrAndKeyHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetForAddress mocks base method.
func (m *MockRepository) GetForAddress(ctx context.Context, address string) ([]bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetForAddress", ctx, address)
	ret0, _ := ret[0].([]bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetForAddress indicates an expected call of GetForAddress.
func (mr *MockRepositoryMockRecorder) GetForAddress(ctx, address any) *RepositoryGetForAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetForAddress", reflect.TypeOf((*MockRepository)(nil).GetForAddress), ctx, address)
	return &RepositoryGetForAddressCall{Call: call}
}

// RepositoryGetForAddressCall wrap *gomock.Call
type RepositoryGetForAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetForAddressCall) Return(arg0 []bigmapdiff.BigMapState, arg1 error) *RepositoryGetForAddressCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetForAddressCall) Do(f func(context.Context, string) ([]bigmapdiff.BigMapState, error)) *RepositoryGetForAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetForAddressCall) DoAndReturn(f func(context.Context, string) ([]bigmapdiff.BigMapState, error)) *RepositoryGetForAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetForOperation mocks base method.
func (m *MockRepository) GetForOperation(ctx context.Context, id int64) ([]bigmapdiff.BigMapDiff, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetForOperation", ctx, id)
	ret0, _ := ret[0].([]bigmapdiff.BigMapDiff)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetForOperation indicates an expected call of GetForOperation.
func (mr *MockRepositoryMockRecorder) GetForOperation(ctx, id any) *RepositoryGetForOperationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetForOperation", reflect.TypeOf((*MockRepository)(nil).GetForOperation), ctx, id)
	return &RepositoryGetForOperationCall{Call: call}
}

// RepositoryGetForOperationCall wrap *gomock.Call
type RepositoryGetForOperationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetForOperationCall) Return(arg0 []bigmapdiff.BigMapDiff, arg1 error) *RepositoryGetForOperationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetForOperationCall) Do(f func(context.Context, int64) ([]bigmapdiff.BigMapDiff, error)) *RepositoryGetForOperationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetForOperationCall) DoAndReturn(f func(context.Context, int64) ([]bigmapdiff.BigMapDiff, error)) *RepositoryGetForOperationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStats mocks base method.
func (m *MockRepository) GetStats(ctx context.Context, ptr int64) (bigmapdiff.Stats, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStats", ctx, ptr)
	ret0, _ := ret[0].(bigmapdiff.Stats)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStats indicates an expected call of GetStats.
func (mr *MockRepositoryMockRecorder) GetStats(ctx, ptr any) *RepositoryGetStatsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStats", reflect.TypeOf((*MockRepository)(nil).GetStats), ctx, ptr)
	return &RepositoryGetStatsCall{Call: call}
}

// RepositoryGetStatsCall wrap *gomock.Call
type RepositoryGetStatsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetStatsCall) Return(arg0 bigmapdiff.Stats, arg1 error) *RepositoryGetStatsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetStatsCall) Do(f func(context.Context, int64) (bigmapdiff.Stats, error)) *RepositoryGetStatsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetStatsCall) DoAndReturn(f func(context.Context, int64) (bigmapdiff.Stats, error)) *RepositoryGetStatsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Keys mocks base method.
func (m *MockRepository) Keys(ctx context.Context, reqCtx bigmapdiff.GetContext) ([]bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Keys", ctx, reqCtx)
	ret0, _ := ret[0].([]bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Keys indicates an expected call of Keys.
func (mr *MockRepositoryMockRecorder) Keys(ctx, reqCtx any) *RepositoryKeysCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Keys", reflect.TypeOf((*MockRepository)(nil).Keys), ctx, reqCtx)
	return &RepositoryKeysCall{Call: call}
}

// RepositoryKeysCall wrap *gomock.Call
type RepositoryKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryKeysCall) Return(states []bigmapdiff.BigMapState, err error) *RepositoryKeysCall {
	c.Call = c.Call.Return(states, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryKeysCall) Do(f func(context.Context, bigmapdiff.GetContext) ([]bigmapdiff.BigMapState, error)) *RepositoryKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryKeysCall) DoAndReturn(f func(context.Context, bigmapdiff.GetContext) ([]bigmapdiff.BigMapState, error)) *RepositoryKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Previous mocks base method.
func (m *MockRepository) Previous(ctx context.Context, diffs []bigmapdiff.BigMapDiff) ([]bigmapdiff.BigMapDiff, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Previous", ctx, diffs)
	ret0, _ := ret[0].([]bigmapdiff.BigMapDiff)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Previous indicates an expected call of Previous.
func (mr *MockRepositoryMockRecorder) Previous(ctx, diffs any) *RepositoryPreviousCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Previous", reflect.TypeOf((*MockRepository)(nil).Previous), ctx, diffs)
	return &RepositoryPreviousCall{Call: call}
}

// RepositoryPreviousCall wrap *gomock.Call
type RepositoryPreviousCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryPreviousCall) Return(arg0 []bigmapdiff.BigMapDiff, arg1 error) *RepositoryPreviousCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryPreviousCall) Do(f func(context.Context, []bigmapdiff.BigMapDiff) ([]bigmapdiff.BigMapDiff, error)) *RepositoryPreviousCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryPreviousCall) DoAndReturn(f func(context.Context, []bigmapdiff.BigMapDiff) ([]bigmapdiff.BigMapDiff, error)) *RepositoryPreviousCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
